### Debugger
##### Неинтерактивный отладчик
[wiki проекта] (http://wiki.cs.hse.ru/%D0%9A%D0%A1:2015:%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82:debuger)

Савельев Никита. 142 группа ПМИ ФКН ВШЭ
##### Библиотеки:
[Dyninst] (http://www.dyninst.org/)

##### Суть
Суть проекта в том, чтобы иметь возможность логировать вызовы программы, в тех случаях, когда ptrace или gdb делают это некорректно или медленно. 
Образ процесса подвергается т.н. _инструментированию_ -- внедрению кода в работающую программу. Таким образом, за счёт отложенного старта, получается в итоге логировать вызовы на порядок быстрее.
##### Принцип работы
* Программа запускает произвольный бинарный исполнительный файл (со всеми аргументами) и получает образ процесса.
* Используя функции библиотеки, мы получаем _граф потока управления_ (или _control flow graph_) для главной функции. 
* Обходим граф, и строим новый для каждой новой вызываемой функции. 
* В точке вызова вставляем "трамплин", так, что, помимо вызова самой функции, вызывается также и printf с названием вызываемой функции в качестве аргумента

##### Итог работы 
Proof of concept.
На данный момент был получен грубый прототип, выполняющий заявленные функции для разных процессов с различной степенью успешности. 
* для небольших учебных программ логирование происходит вполне корректно, вплоть до выполнения многопоточных программ.
* более-менее крупные программы:
  1. иногда инжектор может истратить всю доступную память ещё на этапе инструментирования вызовов. Связано это с неэффективным её (памяти) использованием.
  2. как правило, готовый исполнительный файл доступный пользователю проходит через множество оптимизаций. В таком случае не всегда представляется возможным получить неспоредственно название вызываемых функций.
  3. могут содержать иные нестандартные подходы требующие дополнительного рассмотрения.

##### Пути развития
Дальнейшее развитие проекта включало бы в себя изменение архитектуры таким образом, чтобы снизить вычислительные издержки (overhead) пропорциональные размеру библиотеки: на данный момент Dyninst представляет из себя достаточно обширный
комплекс, который неявно выполняет множество ненужных функций, кроме непосредственно инструментирования.
Далее, улучшение возможно в двух направлениях:
  * __Ускорение работы инструментирования на этапе запуска.__ Может быть достигнуто после более пристального анализа графа. В некоторых случаях возможно начать выполнение программы, до того как инструментирование будет завершено 
  (этакий jit-instrumentation -- если такая аналогия уместна)
  * __Ускорение работы инструментированной программы, после внедрения кода.__ Необходима оптимизация выделения памяти под трамплины и оптимизация непосредственно самих трамплинов.
